\chapter{Introduction}

%This chapter provides a a brief introduction to molecular computation.  

Molecular computing uses parallel interactions between genetic molecules, such as DNA or RNA, to perform computational tasks.  We provide an experimental system for simulating three molecular algorithms.  In this chapter we discuss computing a combinatorial problem with both standard and molecular models of computation.  This discussion continues with an introduction to simulating molecular algorithms.  We conclude the chapter with an overview of the report contents.
%Finally, we provide an introduction to physical gene sequencing techniques for generalized molecular computation.  

\section{Introduction to molecular computation}
	
%<Paragraph> Thesis statement
%				<active sentence> <idea>:{Exp space in polynomial time}
				%	A machine built with exponential space constructs configurations for a NP-complete problem instance in polynomial time.  In this project, we present a simulation system for solving {\sc Satisfiability} with molecular algorithms. 
				
Combinatorial problems, such as {\sc Satisfiability}, may be solved by checking the state for all possible configurations.  In a standard computing environment a brute force search can check all $2^n$ variable assignments in an exponential amount of time.

Molecular computing requires an exponential amount of space to represent combinatorial problems.  This combinatorial space can be filtered in polynomial time with parallel molecular operators.

{\sc Satisfiability} instances can be represented with an expression $\phi$ in conjunctive normal form (CNF).  A CNF expression $\phi$ consists of a conjunctive set of $m$ Boolean disjunctive clauses.  The expression $\phi$ consists of $n$ independent Boolean variables.  We have, e.g.,
\[
\phi = C_1 \wedge C_2 \wedge \cdots \wedge C_m, 
\]
where each clause $C_i$ contains $k$ disjunctive Boolean variables
\[
C_i = (v_1 \vee v_2 \vee \cdots \vee v_k).
\]

Representation of a potential satisfying assignment for a {\sc Satisfiability} instance can be accomplished with an $n$-bit Boolean vector.  A Boolean configuration $B$ for a {\sc Satisfiability} expression may be verified in polynomial time with Algorithm 1.1.1.  $\text{\sc CheckSat}(\phi, B)$ iterates over each of the clauses $C$ in the expression $\phi$.  The $check\_clause$ variable gets set to $False$, assuming that the clause cannot be satisfied.  If the clause can be satisfied with the input configuration $B$, then the algorithm continues.  If each of the $m$ clauses can be satisfied, then $\text{\sc CheckSat}(\phi, B)$ returns $True$; otherwise the algorithm returns $False$.


\input{./algorithms/polyExpExample.tex}

$\text{\sc CheckSat}(\phi, B)$ may be applied as a subroutine in a brute force {\sc Satisfiability} solver.  Algorithm 1.1.2 provides pseudocode for a brute force {\sc Satisfiability} solver $\text{\sc BruteSat}(\phi)$.  The algorithm $\text{\sc BruteSat}(\phi)$ tests a maximum of $2^n$ Boolean configurations with the $\text{\sc CheckSat}(\phi, B)$ algorithm.  If the test configuration $t$ satisfies the input instance $\phi$, then the algorithm returns \texttt{SATISFIABLE}; otherwise the algorithm returns \texttt{UNSATISFIABLE}.

In this project, we consider molecular algorithms to solve {\sc Satisfiability}.  Molecular algorithms permit many combinations to occur in parallel \cite{Adleman:1994:MCS:189441.189442, Lipton95usingdna}.  This permits molecular operations, such as \textit{append} or \textit{extract}, to perform in parallel on all of the string contents of a test tube \cite{Adleman:1994:MCS:189441.189442, Lipton95usingdna, dnaComputingModels2008}.  In Chapter 3, we explore techniques from combinatorial chemistry to enumerate combinatorial states \cite{Lipton95usingdna, furkaBook, dnaComputingModels2008}.  The function $\text{\sc CombinatorialGenerate}(n)$ constructs an exponential number of configurations in linear time.

Let us consider Algorithm 1.1.3 as a simplified version of Lipton's algorithm \cite{Lipton95usingdna, dnaComputingModels2008}.  

\input{./algorithms/extractSat.tex}

The function $\text{\sc ExtractSat}(\phi)$ begins by constructing a combinatorial space $T$ with the subroutine $\text{\sc CombinatorialGenerate}(n)$.  The function $\text{\sc CombinatorialGenerate}(n)$ gets introduced in Chapter 3.  We collect configurations that satisfy the Boolean variables from each of the clauses.  The potential solutions get stored in the tube $T_C$ for each clause.  Once extracting the contents for the current clause $C$ the tube $T_C$ of partial assignments gets stored as $T$.  The process continues for each clause.  If $T$ contains no string configurations, then $\phi$ is \texttt{UNSATISFIABLE}; otherwise $\phi$ is \texttt{SATISFIABLE}, and $T$ contains all satisfying witnesses.

We consider Lipton's algorithm in detail in Chapter 3.  However, the $\text{\sc ExtractSat}(\phi)$ function provides an introductory view of a molecular algorithm.  $\text{\sc ExtractSat}(\phi)$ differs from $\text{\sc BruteSat}(\phi)$ in the method of determining the state for a {\sc Satisfiability} instance.  With the $\text{\sc BruteSat}(\phi)$ algorithm, exponential configurations get generated in exponential time; on the other hand, with $\text{\sc ExtractSat}(\phi)$ exponential configurations get filtered from exponential space.  
%Molecular interactions test many potential states for discrete states of matter.  We consider genetic encodings as a witnessing mechanism for computational configurations.  Hydrogen bonds form complementary base pairs in DNA and RNA.  Complementary genetic string representations encode data for both storage and a matching mechanism.  Molecular computing takes advantage of molecular interactions for general purpose computation.
%%In this project, we consider molecular algorithms for solving {\sc Satisfiability}.				
%		<Paragraph> Introduce algorithms
%				<active sentence> <idea>:{}

				
\section{Simulation of molecular {\sc Satisfiability} solvers}
	
%		<Paragraph> Introduce experiment
%		<Paragraph> Introduce implementation

We consider three molecular algorithms for solving {\sc Satisfiability}: Lipton's algorithm \cite{Lipton95usingdna}, Ogihara and Ray's algorithm \cite{Ogihara:1996:BFS:898228, Ogihara97dna-basedparallel}, and a new algorithm, introduced here, that we call the `Distribution' algorithm.  Lipton's algorithm enumerates a combinatorial space of all potential $n$-bit encodings and filters the combinatorial space to only satisfiable solutions based on the input expression.  Ogihara and Ray's algorithm constructs a space of potential solutions and eliminates non-satisfiable paths.  The Distribution algorithm constructs a set of non-conflicting states for a satisfiable solution.  Chapters 3 and 4 discuss the implementation of these algorithms.

This project introduces a system for simulating three molecular algorithms for solving {\sc Satisfiability}.  The system provides standard operations for molecular computing that we introduce in Chapter 2.  The system records runtime metrics, including counts of molecular operators, solution memory footprints and execution times.  These metrics let us analyze algorithm performance for each {\sc Satisfiability} test instance.

Molecular Simulation, the simulation system introduced in this project, automates execution of DIMACS CNF instances.  Simulation of each of the algorithms measures metrics for a set of randomly generated $3$-{\sc Sat} expressions.  The $3$-{\sc Sat} instances span discrete clause-variable ratios from 0.2 to 14.0 in increments of 0.2, creating a sweep of {\sc Satisfiability} instances.  This experimental setup generates {\sc Satisfiability} problem instances with both \texttt{SATISFIABLE} and \texttt{UNSATISFIABLE} configurations.
%		<Paragraph> Introduce physical machine

\section{Report Overview}

In the following chapters, we describe molecular algorithms for solving {\sc Satisfiability}.  We begin, in Chapter 2 with an introduction to gene sequencing technologies and molecular biology.  The background continues with definitions of molecular operations for operating on DNA or RNA.  Next, we introduce {\sc Satisfiability} with as a language and as a Boolean circuit.  We describe equivalent encodings and classifying characteristics for {\sc Satisfiability}.

Chapters 3 and 4 introduce each of the three molecular algorithms for solving {\sc Satisfiability}.  In Chapter 3, we discuss Lipton's \cite{Lipton95usingdna, dnaComputingModels2008} and Ogihara and Ray's \cite{Ogihara:1996:BFS:898228, Ogihara97dna-basedparallel, dnaBasedImplemetation_Yoshida2000} algorithms for {\sc Satisfiability}.  The chapter concludes with existing simulations and physical implementations of these molecular algorithms.  Chapter 4 introduces the Distribution algorithm.

Chapters 5 and 6 discuss the project implementation.  In Chapter 5, we introduce Molecular Simulation and describe algorithm invocation.  Chapter 6 describes the experimental workflow for importing {\sc Satisfiability} instances for each of the three molecular algorithms under test.

Chapter 7 provides a discussion of algorithm metric performance based on execution test results.  Chapter 8 concludes with the contributions of this project and future directions for molecular computation.