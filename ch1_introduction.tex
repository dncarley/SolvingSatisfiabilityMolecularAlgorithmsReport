\chapter{Introduction}

%This chapter provides a a brief introduction to molecular computation.  

Molecular computing uses parallel interactions between genetic molecules, such as DNA or RNA, to perform computational tasks.  We provide an experimental system for simulating three molecular algorithms.  In this chapter we discuss the process of solving a combinatorial problem with both standard or molecular models of computation.  This discussion includes an introduction to simulating molecular algorithms.  We conclude the chapter with the contents of this report.
%Finally, we provide an introduction to physical gene sequencing techniques for generalized molecular computation.  

\section{Introduction to molecular computation}
	
%<Paragraph> Thesis statement
%				<active sentence> <idea>:{Exp space in polynomial time}
				%	A machine built with exponential space constructs configurations for a NP-complete problem instance in polynomial time.  In this project, we present a simulation system for solving {\sc Satisfiability} with molecular algorithms. 
				
\textsf{NP-complete} problems, such as {\sc Satisfiability}, may be verified in polynomial time with the aid of a short proof called a \textit{witness}; \textsf{NP-complete} problems may be solved by checking the state for all possible \textit{witness candidates}.  In a standard computing environment, brute force search can check all $2^n$ witness candidates in exponential time.

Molecular computing requires exponential space to represent all witness candidates.  This combinatorial space of witness candidates can be filtered in polynomial time with parallel molecular operators.

Conjunctive normal form (CNF) can be used to represent {\sc Satisfiability} instances as a structured input format for Boolean formulas.  A CNF expression $\phi$ consists of a conjunctive set of $m$ Boolean disjunctive clauses.  The expression $\phi$ consists of $n$ independent Boolean variables.  We have, e.g.,
\[
\phi = C_1 \wedge C_2 \wedge \cdots \wedge C_m, 
\]
where each clause $C_i$ contains $k$ disjunctive Boolean variables
\[
C_i = (v_1 \vee v_2 \vee \cdots \vee v_k).
\]

A potentially satisfying witness for a {\sc Satisfiability} instance is a Boolean assignment to the variables that make the formula true.  Such a witness can be represented as an $n$-bit Boolean vector.  Validating a witness candidate for a {\sc Satisfiability} instance may be verified in polynomial time with $\text{\sc CheckSat}(\phi, B)$ (Algorithm 1.1.1 below).  $\text{\sc CheckSat}(\phi, B)$ iterates over each of the clauses $C$ in the expression $\phi$.  The $test\_clause$ variable gets set to $False$, assuming that the clause cannot be satisfied.  If the clause can be satisfied with the input configuration $B$, then the algorithm continues.  If each of the $m$ clauses can be satisfied, then $\text{\sc CheckSat}(\phi, B)$ returns $True$; otherwise the algorithm returns $False$.

\input{./algorithms/polyExpExample.tex}

$\text{\sc CheckSat}(\phi, B)$ may be applied as a subroutine in a brute force {\sc Satisfiability} solver.  Algorithm 1.1.2 provides pseudocode for a brute force {\sc Satisfiability} solver $\text{\sc BruteSat}(\phi)$.  The algorithm $\text{\sc BruteSat}(\phi)$ tests a maximum of $2^n$ Boolean configurations, using the $\text{\sc CheckSat}(\phi, B)$ algorithm.  If the test configuration $t$ satisfies the input instance $\phi$, then the algorithm returns \texttt{SATISFIABLE}; otherwise the algorithm returns \texttt{UNSATISFIABLE}.

In this project, we consider molecular algorithms to solve {\sc Satisfiability}.  Molecular algorithms permit many combinations to occur in parallel \cite{Adleman:1994:MCS:189441.189442, Lipton95usingdna}.  This permits molecular operations, such as \textit{append} or \textit{extract}, to perform in parallel on all of the string contents of a test tube \cite{Adleman:1994:MCS:189441.189442, Lipton95usingdna, dnaComputingModels2008}.  In Chapter 3, we explore techniques from combinatorial chemistry to generate combinatorial sets \cite{Lipton95usingdna, furkaBook, dnaComputingModels2008}.  The function $\text{\sc CombinatorialGenerate}(n)$, which we introduce in Chapter 3, constructs an exponential number of configurations in linear time.

Let us consider Algorithm 1.1.3 as a simplified version of Lipton's algorithm \cite{Lipton95usingdna, dnaComputingModels2008}.  

\input{./algorithms/extractSat.tex}

$\text{\sc ExtractSat}(\phi)$ collects configurations satisfying Boolean variables from each clause in $\phi$.  Initially, $\text{\sc ExtractSat}(\phi)$ constructs a combinatorial space $T$ with the subroutine $\text{\sc CombinatorialGenerate}(n)$.  The initial space $T$ contains configurations representing all potential witness candidates for $\phi$.  The space $T$ gets filtered for each clause to only those configurations that satisfy any of the Boolean variables contained within a clause.  These potential solutions are incrementally mixed into the tube $T_C$ for each clause.  Once extracting the contents for the current clause $C$ the tube $T_C$ of partial assignments gets stored as $T$.  The set $T$ now contains all witnesses that can be satisfied with the previous clauses.  If $T$ contains no string configurations after filtering variables for each clause, then $\phi$ is \texttt{UNSATISFIABLE}; otherwise $\phi$ is \texttt{SATISFIABLE}, and $T$ contains configurations for all satisfying witnesses.

We consider Lipton's algorithm in detail in Chapter 3.  However, the $\text{\sc ExtractSat}(\phi)$ function provides an introductory view of a molecular algorithm.  $\text{\sc ExtractSat}(\phi)$ differs from $\text{\sc BruteSat}(\phi)$ in the method of determining the state for a {\sc Satisfiability} instance.  With the $\text{\sc BruteSat}(\phi)$ algorithm, exponential configurations get generated in exponential time; on the other hand, with $\text{\sc ExtractSat}(\phi)$ exponential configurations get filtered from exponential space.  
%Molecular interactions test many potential states for discrete states of matter.  We consider genetic encodings as a witnessing mechanism for computational configurations.  Hydrogen bonds form complementary base pairs in DNA and RNA.  Complementary genetic string representations encode data for both storage and a matching mechanism.  Molecular computing takes advantage of molecular interactions for general purpose computation.
%%In this project, we consider molecular algorithms for solving {\sc Satisfiability}.				
%		<Paragraph> Introduce algorithms
%				<active sentence> <idea>:{}

				
\section{Simulation of molecular {\sc Satisfiability} solvers}
	
%		<Paragraph> Introduce experiment
%		<Paragraph> Introduce implementation

We consider three molecular algorithms for solving {\sc Satisfiability}: Lipton's algorithm \cite{Lipton95usingdna}, Ogihara and Ray's algorithm \cite{Ogihara:1996:BFS:898228, Ogihara97dna-basedparallel}, and a new algorithm, introduced here, that we call the `Distribution' algorithm.  Lipton's algorithm begins with a combinatorial space of all $n$-bit witness candidates and filters the combinatorial space so that only those that satisfy the input formula remain.  Ogihara and Ray's algorithm constructs a space of witness candidates with a heuristic search.  The Distribution algorithm expands a set of witnesses with non-conflicting variables from each clause.  Chapters 3 and 4 discuss the implementation of these algorithms.

This project introduces a system for simulating three molecular algorithms for solving {\sc Satisfiability}.  The system provides standard operations for molecular computing that we introduce in Chapter 2.  It also records runtime metrics, including counts of molecular operators, solution memory footprints, and execution times.  These metrics let us analyze algorithmic performance of each molecular algorithm.

Molecular Simulation, the simulation system introduced in this project, automates execution of DIMACS CNF instances.  Simulation of each of the algorithms measures metrics for a set of randomly generated $3$-{\sc Sat} expressions.  The $3$-{\sc Sat} instances span discrete clause-variable ratios from 0.2 to 14.0 in increments of 0.2, creating a sweep of {\sc Satisfiability} instances.  This experimental setup generates {\sc Satisfiability} problem instances with both \texttt{SATISFIABLE} and \texttt{UNSATISFIABLE} configurations.
%		<Paragraph> Introduce physical machine

\section{Report Overview}

In the following chapters, we describe molecular algorithms for solving {\sc Satisfiability}.  We begin, in Chapter 2 with an introduction to gene sequencing technologies and molecular biology.  The background continues with definitions of molecular operations for operating on DNA or RNA.  Next, we introduce {\sc Satisfiability} with as a language and as a Boolean circuit.  We describe equivalent encodings and classifying characteristics for {\sc Satisfiability}.

Chapters 3 and 4 introduce each of the three molecular algorithms for solving {\sc Satisfiability}.  In Chapter 3, we discuss Lipton's \cite{Lipton95usingdna, dnaComputingModels2008} and Ogihara and Ray's \cite{Ogihara:1996:BFS:898228, Ogihara97dna-basedparallel, dnaBasedImplemetation_Yoshida2000} algorithms for {\sc Satisfiability}.  The chapter concludes with existing simulations and physical implementations of these molecular algorithms.  Chapter 4 introduces the Distribution algorithm.

Chapters 5 and 6 discuss the project implementation.  In Chapter 5, we introduce Molecular Simulation and describe algorithm invocation.  Chapter 6 describes the experimental workflow for importing {\sc Satisfiability} instances for each of the three molecular algorithms under test.

Chapter 7 provides a discussion of algorithm metric performance based on execution test results.  Chapter 8 concludes with the contributions of this project and future directions for molecular computation.